project: Medallion Architecture Example
engine: spark
description: "Full Bronze-Silver-Gold lakehouse implementation"

connections:
  # Bronze: Raw landing zone
  bronze_layer:
    type: local
    base_path: ./data/bronze

  # Silver: Cleaned and conformed
  silver_layer:
    type: local
    base_path: ./data/silver

  # Gold: Aggregated for business
  gold_layer:
    type: local
    base_path: ./data/gold

  # Source system (simulated)
  source_system:
    type: local
    base_path: ./data/source

story:
  connection: gold_layer
  path: stories/
  auto_generate: true

pipelines:
  # ==========================================
  # 1. Ingestion (Source -> Bronze)
  # ==========================================
  - pipeline: ingest_orders
    layer: bronze
    description: "Ingest raw orders to Bronze Delta"
    nodes:
      - name: read_raw_orders
        read:
          connection: source_system
          path: orders_daily.csv
          format: csv
          options: {header: true}

      - name: add_metadata
        depends_on: [read_raw_orders]
        transform:
          steps:
            - |
              SELECT 
                *,
                current_timestamp() as ingestion_time,
                input_file_name() as source_file
              FROM read_raw_orders

      - name: write_bronze
        depends_on: [add_metadata]
        write:
          connection: bronze_layer
          path: orders
          format: delta
          mode: append

  # ==========================================
  # 2. Refinement (Bronze -> Silver)
  # ==========================================
  - pipeline: refine_orders
    layer: silver
    description: "Clean and deduplicate orders"
    nodes:
      - name: read_bronze
        read:
          connection: bronze_layer
          path: orders
          format: delta

      - name: clean_data
        depends_on: [read_bronze]
        transform:
          steps:
            - |
              SELECT 
                cast(order_id as long) as order_id,
                customer_id,
                cast(order_date as date) as order_date,
                cast(amount as double) as amount,
                upper(status) as status
              FROM read_bronze
              WHERE order_id IS NOT NULL

      - name: deduplicate
        depends_on: [clean_data]
        transform:
          steps:
            - |
              SELECT * FROM (
                SELECT *,
                  row_number() OVER (PARTITION BY order_id ORDER BY ingestion_time DESC) as rn
                FROM clean_data
              ) WHERE rn = 1

      - name: write_silver
        depends_on: [deduplicate]
        write:
          connection: silver_layer
          path: orders
          format: delta
          mode: overwrite
          options:
            partition_by: order_date

  # ==========================================
  # 3. Aggregation (Silver -> Gold)
  # ==========================================
  - pipeline: daily_sales
    layer: gold
    description: "Daily sales aggregation"
    nodes:
      - name: read_silver
        read:
          connection: silver_layer
          path: orders
          format: delta

      - name: aggregate
        depends_on: [read_silver]
        transform:
          steps:
            - |
              SELECT 
                order_date,
                status,
                count(*) as total_orders,
                sum(amount) as total_revenue
              FROM read_silver
              GROUP BY 1, 2

      - name: write_gold
        depends_on: [aggregate]
        write:
          connection: gold_layer
          path: daily_sales_summary
          format: delta
          mode: overwrite
