# Facts vs Dimensions: A Practical Guide

*The building blocks of every data warehouse*

---

## TL;DR

Facts are the "how much" - transactions, events, measurements. Dimensions are the "who, what, where, when" - customers, products, dates, locations. Facts have measures and foreign keys. Dimensions have attributes and surrogate keys. This article explains how to identify each in your data and design a star schema for the Brazilian E-Commerce dataset.

---

## The Restaurant Analogy

Imagine a restaurant.

**Receipts** are facts:
- Table 5, $47.50, 3 items, 8:15 PM
- Table 12, $82.00, 5 items, 8:32 PM
- Table 5, $12.00, 1 item, 9:01 PM

Each receipt is a transaction with numbers you can add up.

**Reference lists** are dimensions:
- Menu (items, prices, categories)
- Staff list (servers, cooks, hostess)
- Table map (table numbers, sections, capacity)
- Calendar (days, holidays, seasons)

Reference lists describe the context around transactions. They change slowly (or never).

That's the core distinction:
- **Facts** = Events that happen. Additive numbers.
- **Dimensions** = Context around events. Descriptive attributes.

---

## Identifying Facts

Ask yourself: "Is this an event or transaction?"

Signs of a fact table:
1. **Timestamps** - When did it happen?
2. **Measures** - Numbers you'd SUM, COUNT, or AVG
3. **Foreign keys** - References to other tables
4. **Many rows** - Facts accumulate over time
5. **Immutable** - Once recorded, facts don't change

In our e-commerce dataset:

| Table | Fact? | Why |
|-------|-------|-----|
| orders | ✅ Yes | Each order is an event |
| order_items | ✅ Yes | Each line item is a transaction |
| payments | ✅ Yes | Each payment is a transaction |
| reviews | ✅ Yes | Each review is an event |

---

## Identifying Dimensions

Ask yourself: "Does this describe something else?"

Signs of a dimension table:
1. **Descriptive attributes** - Names, categories, addresses
2. **Relatively static** - Changes infrequently
3. **Used for grouping** - "Sales by region," "Orders by category"
4. **Used for filtering** - "Show only premium customers"
5. **Natural keys** - Business identifiers like customer_id

In our e-commerce dataset:

| Table | Dimension? | Why |
|-------|------------|-----|
| customers | ✅ Yes | Describes who bought |
| products | ✅ Yes | Describes what was sold |
| sellers | ✅ Yes | Describes who fulfilled |
| geolocation | ✅ Yes | Describes where |
| (date) | ✅ Yes | Describes when (we'll create this) |

---

## Anatomy of a Fact Table

A well-designed fact table has:

```
┌─────────────────────────────────────────────────────────────┐
│                     FACT_ORDERS                              │
├─────────────────────────────────────────────────────────────┤
│ order_sk          (surrogate key - optional)                │
│ order_id          (degenerate dimension - the original ID)  │
├─────────────────────────────────────────────────────────────┤
│ customer_sk       (foreign key → dim_customer)              │
│ date_sk           (foreign key → dim_date)                  │
├─────────────────────────────────────────────────────────────┤
│ order_count       (measure: always 1, for counting)         │
│ total_amount      (measure: sum of order value)             │
│ shipping_cost     (measure: sum of freight)                 │
├─────────────────────────────────────────────────────────────┤
│ load_timestamp    (audit column)                            │
└─────────────────────────────────────────────────────────────┘
```

### Key Concepts

**Surrogate Key (SK)**: A meaningless integer generated by the warehouse. Used for joins. Not from the source system.

**Degenerate Dimension**: A dimension value stored directly in the fact (like `order_id`). No separate dimension table needed.

**Foreign Keys**: References to dimension tables. These are surrogate keys, not natural keys.

**Measures**: Numbers you aggregate. Must be additive at the grain.

**Grain**: The level of detail. "One row per order" or "one row per order line."

---

## Anatomy of a Dimension Table

A well-designed dimension table has:

```
┌─────────────────────────────────────────────────────────────┐
│                     DIM_CUSTOMER                             │
├─────────────────────────────────────────────────────────────┤
│ customer_sk       (surrogate key - generated)                │
│ customer_id       (natural key - from source system)         │
├─────────────────────────────────────────────────────────────┤
│ customer_city     (attribute)                                │
│ customer_state    (attribute)                                │
│ customer_region   (attribute - derived)                      │
│ customer_segment  (attribute)                                │
├─────────────────────────────────────────────────────────────┤
│ is_current        (SCD2: true for current record)            │
│ valid_from        (SCD2: when this version started)          │
│ valid_to          (SCD2: when this version ended)            │
├─────────────────────────────────────────────────────────────┤
│ load_timestamp    (audit column)                             │
└─────────────────────────────────────────────────────────────┘
```

### Key Concepts

**Surrogate Key (SK)**: The primary key of the dimension. An auto-incremented integer.

**Natural Key (NK)**: The business identifier from the source system. Used for matching incoming records.

**Attributes**: Descriptive fields. These are what users filter and group by.

**SCD Columns**: For tracking history (Type 2). `is_current`, `valid_from`, `valid_to`.

---

## Star Schema Design

When facts connect to dimensions, you get a star schema:

```
                    ┌───────────────┐
                    │   dim_date    │
                    └───────┬───────┘
                            │
┌───────────────┐   ┌───────┴───────┐   ┌───────────────┐
│ dim_customer  │───│  fact_orders  │───│  dim_product  │
└───────────────┘   └───────┬───────┘   └───────────────┘
                            │
                    ┌───────┴───────┐
                    │  dim_seller   │
                    └───────────────┘
```

Why "star"? The fact table sits in the center with dimensions radiating outward like points of a star.

---

## Our E-Commerce Star Schema

Let's design the star schema for our dataset:

### Fact Tables

**fact_orders** (grain: one row per order)
- order_id (degenerate)
- customer_sk → dim_customer
- order_date_sk → dim_date
- delivery_date_sk → dim_date
- order_count (always 1)
- is_late (0 or 1)

**fact_order_items** (grain: one row per line item)
- order_id (degenerate)
- order_item_id (degenerate)
- product_sk → dim_product
- seller_sk → dim_seller
- order_date_sk → dim_date
- quantity (always 1 in this dataset)
- price
- freight_value
- line_total

**fact_payments** (grain: one row per payment)
- order_id (degenerate)
- payment_type (degenerate)
- payment_date_sk → dim_date
- payment_count (always 1)
- payment_amount

**fact_reviews** (grain: one row per review)
- order_id (degenerate)
- review_date_sk → dim_date
- review_count (always 1)
- review_score

### Dimension Tables

**dim_date**
- date_sk (YYYYMMDD format)
- full_date
- day_of_week
- month, quarter, year
- fiscal_year, fiscal_quarter
- is_weekend, is_holiday

**dim_customer**
- customer_sk
- customer_id (natural key)
- customer_city
- customer_state
- customer_region

**dim_product**
- product_sk
- product_id (natural key)
- product_category
- product_weight_g
- product_volume_cm3

**dim_seller**
- seller_sk
- seller_id (natural key)
- seller_city
- seller_state
- seller_region

**dim_geolocation** (optional, can denormalize into customer/seller)
- zip_code (natural key)
- latitude
- longitude
- city
- state

---

## Why Surrogate Keys?

You might wonder: "Why not just use `customer_id`?"

### Problem 1: Natural Keys Change

Business keys can be reassigned, reformatted, or merged. Surrogate keys are stable.

### Problem 2: Multi-Source Integration

If you have two source systems with different customer ID formats, surrogate keys unify them.

### Problem 3: SCD2 History

With SCD2, the same `customer_id` can have multiple rows (historical versions). You need a unique key per row.

### Problem 4: Join Performance

Integer joins are faster than string joins. `customer_sk` (INT) beats `customer_id` (VARCHAR).

---

## Odibi Configuration: Dimensions

Here's how to build `dim_customer` with Odibi:

```yaml
- name: dim_customer
  description: "Customer dimension with surrogate key"
  
  depends_on: [silver_customers]
  
  pattern:
    type: dimension
    params:
      natural_key: customer_id
      surrogate_key: customer_sk
      scd_type: 1  # Overwrite (no history)
      unknown_member: true  # Add SK=0 for orphans
      audit:
        load_timestamp: true
        source_system: "ecommerce"
  
  # Add derived attributes
  transform:
    steps:
      - function: derive_columns
        params:
          columns:
            customer_region: |
              CASE 
                WHEN customer_state IN ('SP', 'RJ', 'MG', 'ES') THEN 'Southeast'
                WHEN customer_state IN ('PR', 'SC', 'RS') THEN 'South'
                WHEN customer_state IN ('BA', 'SE', 'AL', 'PE', 'PB', 'RN', 'CE', 'PI', 'MA') THEN 'Northeast'
                WHEN customer_state IN ('MT', 'MS', 'GO', 'DF') THEN 'Central-West'
                ELSE 'North'
              END
  
  write:
    connection: gold
    path: dim_customer
    format: delta
```

---

## Odibi Configuration: Facts

Here's how to build `fact_order_items`:

```yaml
- name: fact_order_items
  description: "Order line items fact table"
  
  depends_on: 
    - silver_order_items
    - dim_customer
    - dim_product
    - dim_seller
    - dim_date
  
  pattern:
    type: fact
    params:
      grain: [order_id, order_item_id]
      
      dimensions:
        - source_column: product_id
          dimension_table: dim_product
          dimension_key: product_id
          surrogate_key: product_sk
        
        - source_column: seller_id
          dimension_table: dim_seller
          dimension_key: seller_id
          surrogate_key: seller_sk
      
      orphan_handling: unknown  # Use SK=0 for missing dimensions
      
      measures:
        - quantity: "1"  # Each row is one item
        - price
        - freight_value
        - line_total: "price + freight_value"
      
      audit:
        load_timestamp: true
  
  write:
    connection: gold
    path: fact_order_items
    format: delta
```

---

## Common Mistakes

### 1. Using Natural Keys in Facts

❌ Wrong:
```sql
SELECT customer_id, SUM(amount)
FROM fact_orders
JOIN silver_customers ON ...
```

✅ Right:
```sql
SELECT d.customer_id, SUM(f.amount)
FROM fact_orders f
JOIN dim_customer d ON f.customer_sk = d.customer_sk
```

### 2. Putting Measures in Dimensions

❌ Wrong: `dim_customer.total_orders` (this is a measure)

✅ Right: Calculate from fact table when needed

### 3. Missing Unknown Member

❌ Wrong: Orphan records break joins

✅ Right: Add row with `SK=0` and "Unknown" attributes

### 4. Wrong Grain

❌ Wrong: `fact_orders` with one row per customer (too high)

✅ Right: `fact_orders` with one row per order (transaction grain)

### 5. Non-Additive Measures

❌ Wrong: Storing percentages in facts (can't SUM percentages)

✅ Right: Store numerator and denominator, calculate percentage in reporting

---

## Querying the Star Schema

Once built, the star schema enables clean queries:

### Total Revenue by Region and Month

```sql
SELECT 
  dc.customer_region,
  dd.month_name,
  SUM(f.line_total) as revenue
FROM fact_order_items f
JOIN dim_customer dc ON f.customer_sk = dc.customer_sk
JOIN dim_date dd ON f.order_date_sk = dd.date_sk
WHERE dd.year = 2018
GROUP BY dc.customer_region, dd.month_name
ORDER BY dc.customer_region, dd.month_name
```

### Top 10 Products by Revenue

```sql
SELECT 
  dp.product_category,
  dp.product_id,
  SUM(f.line_total) as revenue,
  COUNT(*) as order_count
FROM fact_order_items f
JOIN dim_product dp ON f.product_sk = dp.product_sk
GROUP BY dp.product_category, dp.product_id
ORDER BY revenue DESC
LIMIT 10
```

### Late Delivery Rate by Seller State

```sql
SELECT 
  ds.seller_state,
  SUM(f.is_late) as late_orders,
  COUNT(*) as total_orders,
  ROUND(100.0 * SUM(f.is_late) / COUNT(*), 2) as late_pct
FROM fact_orders f
JOIN dim_seller ds ON f.seller_sk = ds.seller_sk
GROUP BY ds.seller_state
ORDER BY late_pct DESC
```

---

## Key Takeaways

1. **Facts are events** - Transactions with measures and timestamps
2. **Dimensions are context** - Descriptive attributes for filtering and grouping
3. **Surrogate keys enable history** - Stable identifiers across time
4. **Grain defines uniqueness** - "One row per ___"
5. **Star schema simplifies queries** - Fact in center, dimensions around

---

## Next Steps

Now that we understand facts and dimensions, we'll build them:

1. **Date Dimension** - Every warehouse needs one
2. **Dimension Tables** - Customer, Product, Seller
3. **Fact Tables** - Orders, Order Items, Reviews

Next article: **Building a Date Dimension from Scratch**.

---

## Connect

- **LinkedIn:** [Your LinkedIn URL]
- **GitHub:** [Odibi Repository URL]
- **Medium:** Follow for more articles in this series
